{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/nginx/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/nginx/",
    "feed_url": "https://blog.josephscott.org/tag/nginx/feed/json/",
    "language": "en-US",
    "title": "nginx &#8211; Joseph Scott",
    "items": [
        {
            "id": "https://josephscott.org/?p=14048",
            "url": "https://blog.josephscott.org/2015/11/20/brotli-for-nginx/",
            "title": "Brotli for Nginx",
            "content_html": "<p>Two months ago Google announced <a href=\"http://google-opensource.blogspot.com/2015/09/introducing-brotli-new-compression.html\">Brotli</a>, a new compression format:</p>\n<blockquote><p>\nBrotli is a whole new data format. This new format allows us to get 20\u201326% higher compression ratios over Zopfli. In our study \u2018Comparison of Brotli, Deflate, Zopfli, LZMA, LZHAM and Bzip2 Compression Algorithms\u2019 we show that Brotli is roughly as fast as zlib\u2019s Deflate implementation. At the same time, it compresses slightly more densely than LZMA and bzip2 on the Canterbury corpus. The higher data density is achieved by a 2nd order context modeling, re-use of entropy codes, larger memory window of past data and joint distribution codes. Just like Zopfli, the new algorithm is named after Swiss bakery products. Br\u00f6tli means \u2018small bread\u2019 in Swiss German.\n</p></blockquote>\n<p>Compression is a big deal for web performance, being able to send the same file with fewer bytes is a big win.</p>\n<p>There are now two Nginx modules for supporting Brotli compression: <a href=\"https://github.com/google/ngx_brotli\">ngx_brotli from Google</a> and <a href=\"https://github.com/cloudflare/ngx_brotli_module\">ngx_brotli_module from CloudFlare</a>.</p>\n",
            "content_text": "Two months ago Google announced Brotli, a new compression format:\n\nBrotli is a whole new data format. This new format allows us to get 20\u201326% higher compression ratios over Zopfli. In our study \u2018Comparison of Brotli, Deflate, Zopfli, LZMA, LZHAM and Bzip2 Compression Algorithms\u2019 we show that Brotli is roughly as fast as zlib\u2019s Deflate implementation. At the same time, it compresses slightly more densely than LZMA and bzip2 on the Canterbury corpus. The higher data density is achieved by a 2nd order context modeling, re-use of entropy codes, larger memory window of past data and joint distribution codes. Just like Zopfli, the new algorithm is named after Swiss bakery products. Br\u00f6tli means \u2018small bread\u2019 in Swiss German.\n\nCompression is a big deal for web performance, being able to send the same file with fewer bytes is a big win.\nThere are now two Nginx modules for supporting Brotli compression: ngx_brotli from Google and ngx_brotli_module from CloudFlare.",
            "date_published": "2015-11-20T09:15:55-07:00",
            "date_modified": "2015-11-20T09:15:55-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "brotli",
                "cloudflare",
                "compression",
                "google",
                "nginx",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=14086",
            "url": "https://blog.josephscott.org/2015/10/15/nginx-http2/",
            "title": "Nginx HTTP/2",
            "content_html": "<p>With version 1.9.5 <a href=\"http://nginx.org/\">Nginx</a> added support for <a href=\"http://nginx.org/en/docs/http/ngx_http_v2_module.html\">http/2</a>.  Last night up I switched my Nginx configuration for josephscott.org from SPDY to H2.</p>\n<p>So far everything appears to be working normal, if you do find something broken <a href=\"https://josephscott.org/contact/\">please let me know</a>.</p>\n",
            "content_text": "With version 1.9.5 Nginx added support for http/2.  Last night up I switched my Nginx configuration for josephscott.org from SPDY to H2.\nSo far everything appears to be working normal, if you do find something broken please let me know.",
            "date_published": "2015-10-15T06:29:32-06:00",
            "date_modified": "2015-10-15T06:29:32-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "http2",
                "nginx",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=12689",
            "url": "https://blog.josephscott.org/2015/09/11/tracking-tcp-round-trip-time-in-nginx/",
            "title": "Tracking TCP Round Trip Time in Nginx",
            "content_html": "<p>The <a href=\"http://linuxgazette.net/136/pfeiffer.html\">TCP_INFO</a> option provides information about round trip times ( RTT ) for a TCP connection.  Turns out that Nginx can expose this information for you as <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html\">embedded variables</a>:</p>\n<blockquote><p>\n$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space</p>\n<p>information about the client TCP connection; available on systems that support the TCP_INFO socket option\n</p></blockquote>\n<p>Easy to log this information.  From there: periodically parse Nginx logs looking for client IP and RTT data, GEO IP lookup on the client, compute the median RTT value for each country/state, color code countries from highest to lowest RTT, then use Google Maps for the display.</p>\n<p>You&#8217;ll have yourself a nice page showing the RTT values across the world for visitors to your site.</p>\n",
            "content_text": "The TCP_INFO option provides information about round trip times ( RTT ) for a TCP connection.  Turns out that Nginx can expose this information for you as embedded variables:\n\n$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space\ninformation about the client TCP connection; available on systems that support the TCP_INFO socket option\n\nEasy to log this information.  From there: periodically parse Nginx logs looking for client IP and RTT data, GEO IP lookup on the client, compute the median RTT value for each country/state, color code countries from highest to lowest RTT, then use Google Maps for the display.\nYou&#8217;ll have yourself a nice page showing the RTT values across the world for visitors to your site.",
            "date_published": "2015-09-11T09:01:53-06:00",
            "date_modified": "2015-09-11T09:01:53-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "nginx",
                "tcp/ip",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=12371",
            "url": "https://blog.josephscott.org/2015/05/19/dynamically-generated-certificates/",
            "title": "Dynamically Generated Certificates",
            "content_html": "<blockquote><p>tl;dr: generate dynamic certificates on the fly with nginx.</p></blockquote>\n<p>Leveraging <a href=\"http://openresty.org/\">OpenResty</a> to <a href=\"http://blog.dutchcoders.io/openresty-with-dynamic-generated-certificates/\">generate certificates on demand</a>, which follows fairly direct pattern:</p>\n<ul>\n<li>Generate private key</li>\n<li>Generate signing request ( CSR )</li>\n<li>Sign the CSR with a CA</li>\n<li>Use the new key</li>\n</ul>\n<p>A little bit of <a href=\"http://www.lua.org/\">Lua</a> inside <a href=\"http://nginx.org/\">Nginx</a> goes a surprisingly long way.</p>\n",
            "content_text": "tl;dr: generate dynamic certificates on the fly with nginx.\nLeveraging OpenResty to generate certificates on demand, which follows fairly direct pattern:\n\nGenerate private key\nGenerate signing request ( CSR )\nSign the CSR with a CA\nUse the new key\n\nA little bit of Lua inside Nginx goes a surprisingly long way.",
            "date_published": "2015-05-19T11:08:50-06:00",
            "date_modified": "2015-05-19T11:08:50-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "https",
                "lua",
                "nginx",
                "openresty",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=11433",
            "url": "https://blog.josephscott.org/2014/12/03/nginx-1-7-8-fixes-200ms-delay-with-spdy/",
            "title": "Nginx 1.7.8 \u2013 Fixes 200ms Delay With SPDY",
            "content_html": "<p><a href=\"http://nginx.org/\">Nginx 1.7.8</a> is now available, and I&#8217;m really happy to see this entry in the <a href=\"http://nginx.org/en/CHANGES\">changelog</a>:</p>\n<blockquote><p>\nFeature: now the &#8220;tcp_nodelay&#8221; directive works with SPDY connections.\n</p></blockquote>\n<p>To be more specific, <a href='http://trac.nginx.org/nginx/changeset/2c10db908b8c4a9c0532c58830275d5ad84ae686/nginx/src'>this commit</a>.</p>\n<hr />\n<h3>The Story</h3>\n<p>Back in September I spun up a <a href=\"https://sites.google.com/a/webpagetest.org/docs/private-instances\">private instance</a> of <a href=\"http://webpagetest.org/\">webpagetest</a> ( WPT ).  One of the first things I did was run near optimal condition tests.  I wanted to see what the lower bound were for a few performance tests.  The test system was very close to one of <a href=\"http://automattic.com/\">our</a> data centers ( less than 1ms ping times ), so I configured tests to use Chrome as the browser, with no traffic shaping.</p>\n<p>Like a kid with a new toy on Christmas morning I started running tests against this private WPT instance.  Quickly something odd came up.  In some cases we were seeing requests for very small ( sometimes less than 1kb ) resources take much longer than they should have.  And by &#8220;much longer&#8221;, I mean these were 3 to 4 times slower than requests for larger resources.</p>\n<p>Long story short, these slower small requests were seeing ~200ms delays in time to first byte ( TTFB ).  But it only happened with <a href=\"http://en.wikipedia.org/wiki/SPDY\">SPDY</a>, with compression enabled, for small files ( my tests showed 1,602 bytes or smaller ), when the small file was the first resource requested in the SPDY connection.  Once I was able to list all of the variables that needed to be in place it was very simple to reproduce the problem using WPT.</p>\n<p>Some of you will look at the mention of a ~200ms delay and immediately recognize this as a <a href=\"http://support.microsoft.com/kb/214397\">delayed ack issue</a>:</p>\n<blockquote><p>\nWhen a Microsoft TCP stack receives a data packet, a 200-ms delay timer goes off. When an ACK is eventually sent, the delay timer is reset and will initiate another 200-ms delay when the next data packet is received.\n</p></blockquote>\n<p>( Note that the WPT tester system in our instance uses Windows, so that we can test Internet Explorer )</p>\n<p>But that is why Nginx has a <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nodelay\">tcp_nodelay</a> option.  Unfortunately it wasn&#8217;t being applied when these variables came together in a SPDY connection.  I started a <a href=\"http://www.webpagetest.org/forums/showthread.php?tid=13322\">thread in the WPT forums</a> about this and we all basically agreed that this was the issue.</p>\n<p>The systems team at <a href=\"http://automattic.com/\">Automattic</a> reached out the Nginx team, describing what we were observing and how to reproduce it.  They sent back a patch, which I ran through my tests and confirmed that it fixed the problem.  The patch led to the <a href=\"http://trac.nginx.org/nginx/changeset/2c10db908b8c4a9c0532c58830275d5ad84ae686/nginx/src\">commit</a> I mentioned above.  And now that change is part of the Nginx 1.7.8 release.</p>\n<h3>Waterfall</h3>\n<p>Here is what this looks like in action.  First, a WPT waterfall graph using Nginx 1.7.7:</p>\n<p><a href=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-177-1.png\"><img loading=\"lazy\" src=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-177-1.png\" alt=\"nginx-177\" width=\"966\" height=\"433\" class=\"aligncenter size-full wp-image-11467\" srcset=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-177-1.png 966w, https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-177-1-300x134.png 300w, https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-177-1-768x344.png 768w\" sizes=\"(max-width: 966px) 100vw, 966px\" /></a></p>\n<p>That TTFB of 212ms is significantly slower than it should be.  Compare that with the same test conditions using Nginx 1.7.8:</p>\n<p><a href=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-178-1.png\"><img loading=\"lazy\" src=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-178-1.png\" alt=\"nginx-178\" width=\"970\" height=\"425\" class=\"aligncenter size-full wp-image-11468\" srcset=\"https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-178-1.png 970w, https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-178-1-300x131.png 300w, https://blog.josephscott.org/wp-content/uploads/2014/12/nginx-178-1-768x336.png 768w\" sizes=\"(max-width: 970px) 100vw, 970px\" /></a></p>\n<p>A TTFB of 15ms is inline with what I expected to see.  Going from 212ms to 15ms is a 14x improvement!  The total request time dropped from 266ms to 69ms, a 3.8X improvement.  I&#8217;ll take gains like that anytime.</p>\n<h3>Reproducing This Yourself</h3>\n<p>I ran numerous tests during this process.  To make running new tests easier I put together a simple script to take care of the Nginx build and configuration:</p>\nView the code on <a href=\"https://gist.github.com/b79e79a8b7e17ca1bdb7\">Gist</a>.\n<p>For each test I&#8217;d spin up a new DigitalOcean VM with Ubuntu 14.04 LTS.  The build script would complete in a few minutes and then I&#8217;d run new WPT tests.</p>\n<p>Conveniently it turns out that the default <a href=\"http://trac.nginx.org/nginx/browser/nginx/docs/html/index.html\">Welcome to nginx!</a> page is small enough to trigger the ~200ms delay.</p>\n<p>With all of that in place you can run a test at <a href=\"http://www.webpagetest.org/\">webpagetest.org</a> to see this in action.  I&#8217;ve been using the following test config:</p>\n<p>&#8211; Test Location: Dulles, VA<br />\n&#8211; Browser: Chrome<br />\n&#8211; Connection: Native Connection ( No Traffic Shaping )<br />\n&#8211; &#8220;Ignore SSL Certificate Errors&#8221; ( under the Advanced tab ) &#8212; this is need because I&#8217;ve been using a self signed cert</p>\n<p>The &#8220;Dulles, VA&#8221; location has a fast enough route to DigitalOcean &#8220;New York 3&#8221; that you can still observe the ~200ms TTFB difference between Nginx 1.7.7 and 1.7.8.</p>\n<hr />\n<p>A big thank you to the Nginx team for fixing this.</p>\n",
            "content_text": "Nginx 1.7.8 is now available, and I&#8217;m really happy to see this entry in the changelog:\n\nFeature: now the &#8220;tcp_nodelay&#8221; directive works with SPDY connections.\n\nTo be more specific, this commit.\n\nThe Story\nBack in September I spun up a private instance of webpagetest ( WPT ).  One of the first things I did was run near optimal condition tests.  I wanted to see what the lower bound were for a few performance tests.  The test system was very close to one of our data centers ( less than 1ms ping times ), so I configured tests to use Chrome as the browser, with no traffic shaping.\nLike a kid with a new toy on Christmas morning I started running tests against this private WPT instance.  Quickly something odd came up.  In some cases we were seeing requests for very small ( sometimes less than 1kb ) resources take much longer than they should have.  And by &#8220;much longer&#8221;, I mean these were 3 to 4 times slower than requests for larger resources.\nLong story short, these slower small requests were seeing ~200ms delays in time to first byte ( TTFB ).  But it only happened with SPDY, with compression enabled, for small files ( my tests showed 1,602 bytes or smaller ), when the small file was the first resource requested in the SPDY connection.  Once I was able to list all of the variables that needed to be in place it was very simple to reproduce the problem using WPT.\nSome of you will look at the mention of a ~200ms delay and immediately recognize this as a delayed ack issue:\n\nWhen a Microsoft TCP stack receives a data packet, a 200-ms delay timer goes off. When an ACK is eventually sent, the delay timer is reset and will initiate another 200-ms delay when the next data packet is received.\n\n( Note that the WPT tester system in our instance uses Windows, so that we can test Internet Explorer )\nBut that is why Nginx has a tcp_nodelay option.  Unfortunately it wasn&#8217;t being applied when these variables came together in a SPDY connection.  I started a thread in the WPT forums about this and we all basically agreed that this was the issue.\nThe systems team at Automattic reached out the Nginx team, describing what we were observing and how to reproduce it.  They sent back a patch, which I ran through my tests and confirmed that it fixed the problem.  The patch led to the commit I mentioned above.  And now that change is part of the Nginx 1.7.8 release.\nWaterfall\nHere is what this looks like in action.  First, a WPT waterfall graph using Nginx 1.7.7:\n\nThat TTFB of 212ms is significantly slower than it should be.  Compare that with the same test conditions using Nginx 1.7.8:\n\nA TTFB of 15ms is inline with what I expected to see.  Going from 212ms to 15ms is a 14x improvement!  The total request time dropped from 266ms to 69ms, a 3.8X improvement.  I&#8217;ll take gains like that anytime.\nReproducing This Yourself\nI ran numerous tests during this process.  To make running new tests easier I put together a simple script to take care of the Nginx build and configuration:\nView the code on Gist.\nFor each test I&#8217;d spin up a new DigitalOcean VM with Ubuntu 14.04 LTS.  The build script would complete in a few minutes and then I&#8217;d run new WPT tests.\nConveniently it turns out that the default Welcome to nginx! page is small enough to trigger the ~200ms delay.\nWith all of that in place you can run a test at webpagetest.org to see this in action.  I&#8217;ve been using the following test config:\n&#8211; Test Location: Dulles, VA\n&#8211; Browser: Chrome\n&#8211; Connection: Native Connection ( No Traffic Shaping )\n&#8211; &#8220;Ignore SSL Certificate Errors&#8221; ( under the Advanced tab ) &#8212; this is need because I&#8217;ve been using a self signed cert\nThe &#8220;Dulles, VA&#8221; location has a fast enough route to DigitalOcean &#8220;New York 3&#8221; that you can still observe the ~200ms TTFB difference between Nginx 1.7.7 and 1.7.8.\n\nA big thank you to the Nginx team for fixing this.",
            "date_published": "2014-12-03T18:03:55-07:00",
            "date_modified": "2014-12-03T18:03:55-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "nginx",
                "spdy",
                "webperf",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=10358",
            "url": "https://blog.josephscott.org/2014/04/28/tried-spdy/",
            "title": "Tried Out SPDY",
            "content_html": "<p>Zack Tollman suggested I <a href=\"https://josephscott.org/archives/2014/04/update-nginx-for-better-https-performance/#comment-15955\" title=\"Comments like these make writing posts more enjoyable.\">try out SPDY</a> with my updated Nginx install.  While I&#8217;m sad at the idea of giving up a plain text HTTP API, I was curious to see what SPDY looked like on this site.</p>\n<p>I was disappointed with the results.  The fastest page load time out of 5 runs without SPDY was 1.039 s.  With SPDY the fastest result was 1.273 s.  I then did several more runs of the same test with SPDY enabled to see if any of them could get close to the 1.0 s base line.  None of them did, most came in close to 2 seconds.  I had honestly expected to see SPDY perform better.  That said this type of testing is not particularly rigorous, so take these numbers with a sufficiently large grain of salt.</p>\n<p>Given the initial poor showing of SPDY in these tests I&#8217;m going to leave it turned off for now.</p>\n",
            "content_text": "Zack Tollman suggested I try out SPDY with my updated Nginx install.  While I&#8217;m sad at the idea of giving up a plain text HTTP API, I was curious to see what SPDY looked like on this site.\nI was disappointed with the results.  The fastest page load time out of 5 runs without SPDY was 1.039 s.  With SPDY the fastest result was 1.273 s.  I then did several more runs of the same test with SPDY enabled to see if any of them could get close to the 1.0 s base line.  None of them did, most came in close to 2 seconds.  I had honestly expected to see SPDY perform better.  That said this type of testing is not particularly rigorous, so take these numbers with a sufficiently large grain of salt.\nGiven the initial poor showing of SPDY in these tests I&#8217;m going to leave it turned off for now.",
            "date_published": "2014-04-28T13:52:14-06:00",
            "date_modified": "2014-04-28T13:52:14-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "http",
                "nginx",
                "performance",
                "spdy",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=10261",
            "url": "https://blog.josephscott.org/2014/04/22/update-nginx-for-better-https-performance/",
            "title": "Update Nginx For Better HTTPS Performance",
            "content_html": "<p>I decided to try out this suggestion from <a href=\"http://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/\" title=\"Time to first byte is one of my favorite topics.\">Optimizing NGINX TLS Time To First Byte (TTFB)</a> ( which <a href=\"https://josephscott.org/archives/2013/12/nginx-tls-time-to-first-byte/\" title=\"I should have read this in full sooner.\">I mentioned at the end of 2013</a> ):</p>\n<blockquote><p>\nAfter digging through the nginx source code, one stumbles <a href=\"https://github.com/nginx/nginx/commit/e52bddaaa90e64b2291f6e58ef1a2cff71604f6a#diff-0584d16332cf0d6dd9adb990a3c76a0cR539\">onto this gem</a>. Turns out, any nginx version prior to 1.5.6 has this issue: certificates over 4KB in size incur an extra roundtrip, turning a two roundtrip handshake into a three roundtrip affair &#8211; yikes. Worse, in this particular case we trigger another unfortunate edge case in Windows TCP stack: the client ACKs the first few packets from the server, but then waits ~200ms before it triggers a delayed ACK for the last segment. In total, that results in extra 580ms of latency that we did not expect.\n</p></blockquote>\n<p>I&#8217;ve been using Nginx 1.4.x from the Ubuntu package collection on this site.  A few <a href=\"http://www.webpagetest.org/\" title=\"Still one of my favorite performance testing resources.\">webpagetest.org</a> runs showed that HTTPS negotiation was taking more than 300ms on the initial request.  After updating to Nginx 1.5.13 more tests showed HTTPS negotiation was down around 250ms.</p>\n<p>The 50ms savings isn&#8217;t nearly as dramatic as the worst case scenario described in the quote above, but I&#8217;ll take it.</p>\n",
            "content_text": "I decided to try out this suggestion from Optimizing NGINX TLS Time To First Byte (TTFB) ( which I mentioned at the end of 2013 ):\n\nAfter digging through the nginx source code, one stumbles onto this gem. Turns out, any nginx version prior to 1.5.6 has this issue: certificates over 4KB in size incur an extra roundtrip, turning a two roundtrip handshake into a three roundtrip affair &#8211; yikes. Worse, in this particular case we trigger another unfortunate edge case in Windows TCP stack: the client ACKs the first few packets from the server, but then waits ~200ms before it triggers a delayed ACK for the last segment. In total, that results in extra 580ms of latency that we did not expect.\n\nI&#8217;ve been using Nginx 1.4.x from the Ubuntu package collection on this site.  A few webpagetest.org runs showed that HTTPS negotiation was taking more than 300ms on the initial request.  After updating to Nginx 1.5.13 more tests showed HTTPS negotiation was down around 250ms.\nThe 50ms savings isn&#8217;t nearly as dramatic as the worst case scenario described in the quote above, but I&#8217;ll take it.",
            "date_published": "2014-04-22T15:37:41-06:00",
            "date_modified": "2014-04-22T15:37:41-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "https",
                "nginx",
                "performance",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=9676",
            "url": "https://blog.josephscott.org/2013/12/26/nginx-tls-time-to-first-byte/",
            "title": "NGINX TLS Time To First Byte",
            "content_html": "<p>Ilya Grigorik on <a href=\"http://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/\" title=\"A race before the race.\">optimizing NGINX TLS time to first byte (TTTFB)</a>:</p>\n<blockquote><p>\nlet&#8217;s now turn to the practical matter of picking and tuning the server to deliver the best results. One would hope that the default \u201cout of the box\u201d experience for most servers would do a good job\u2026 unfortunately, that is not the case. Let&#8217;s take a closer look nginx\n</p></blockquote>\n<p>In the simplest terms, TLS involves more work.  The current realities of securing communications means we don&#8217;t have a good way to avoid doing that additional work, indeed we will be doing it more often than we ever have before.  The end result is that we need to spend more time thinking about how to optimize the HTTPS experience for all users.</p>\n",
            "content_text": "Ilya Grigorik on optimizing NGINX TLS time to first byte (TTTFB):\n\nlet&#8217;s now turn to the practical matter of picking and tuning the server to deliver the best results. One would hope that the default \u201cout of the box\u201d experience for most servers would do a good job\u2026 unfortunately, that is not the case. Let&#8217;s take a closer look nginx\n\nIn the simplest terms, TLS involves more work.  The current realities of securing communications means we don&#8217;t have a good way to avoid doing that additional work, indeed we will be doing it more often than we ever have before.  The end result is that we need to spend more time thinking about how to optimize the HTTPS experience for all users.",
            "date_published": "2013-12-26T17:29:03-07:00",
            "date_modified": "2013-12-26T17:29:03-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "https",
                "nginx",
                "ssl",
                "time-to-first-byte",
                "tls",
                "Posts"
            ]
        },
        {
            "id": "http://josephscott.org/?p=4010",
            "url": "https://blog.josephscott.org/2011/04/28/mnpp/",
            "title": "MNPP",
            "content_html": "<p><a href=\"http://getmnpp.org/\">MNPP</a> is Mac + Nginx + Percona + PHP.  Could be a handy alternative to MAMP.</p>\n",
            "content_text": "MNPP is Mac + Nginx + Percona + PHP.  Could be a handy alternative to MAMP.",
            "date_published": "2011-04-28T16:32:40-06:00",
            "date_modified": "2011-04-28T16:32:40-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "macosx",
                "mnpp",
                "MySQL",
                "nginx",
                "percona",
                "PHP",
                "Posts"
            ]
        },
        {
            "id": "http://josephscott.org/?p=3495",
            "url": "https://blog.josephscott.org/2011/02/07/nginx-redirect-non-ssl-requests/",
            "title": "Nginx, Redirect non-SSL Requests",
            "content_html": "<p>Since I managed to do this incorrectly a couple of times I figured it was worth noting here.</p>\n<p>You already have a working site setup in Nginx that uses SSL.  Now you want to make sure that any non-SSL requests to the site get redirected.  Turns out to be very simple:</p>\n<p>[sourcecode lang=&#8221;plain&#8221;]<br />\nserver {<br />\n  listen 80;<br />\n  server_name example.com;<br />\n  rewrite ^(.*) https://$server_name$1 permanent;<br />\n}<br />\n[/sourcecode]</p>\n<p>This sends back an <code>HTTP/1.1 301 Moved Permanently</code> response for non-SSL requests for example.com.</p>\n<p>Three short and easy to read lines, I like it.</p>\n",
            "content_text": "Since I managed to do this incorrectly a couple of times I figured it was worth noting here.\nYou already have a working site setup in Nginx that uses SSL.  Now you want to make sure that any non-SSL requests to the site get redirected.  Turns out to be very simple:\n[sourcecode lang=&#8221;plain&#8221;]\nserver {\n  listen 80;\n  server_name example.com;\n  rewrite ^(.*) https://$server_name$1 permanent;\n}\n[/sourcecode]\nThis sends back an HTTP/1.1 301 Moved Permanently response for non-SSL requests for example.com.\nThree short and easy to read lines, I like it.",
            "date_published": "2011-02-07T10:51:43-07:00",
            "date_modified": "2011-02-07T10:51:43-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "nginx",
                "ssl",
                "Posts"
            ]
        }
    ]
}