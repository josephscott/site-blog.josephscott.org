{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/anthony-ferrara/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/anthony-ferrara/",
    "feed_url": "https://blog.josephscott.org/tag/anthony-ferrara/feed/json/",
    "language": "en-US",
    "title": "anthony-ferrara &#8211; Joseph Scott",
    "items": [
        {
            "id": "https://josephscott.org/?p=12518",
            "url": "https://blog.josephscott.org/2015/09/18/context-escaping/",
            "title": "Context Escaping",
            "content_html": "<p>Anthony Ferrara taking on the painful process of automatically determining the correct context for escaping data in templates:</p>\n<blockquote><p>\nImagine being able to put a variable in a JavaScript string in your template, and have the engine transparently encode it correctly for you. Awesome, right?\n</p></blockquote>\n<p>From <a href=\"http://blog.ircmaxell.com/2015/05/tries-and-lexers.html\">Tries and Lexers</a>.</p>\n<p>The best attempt I&#8217;ve seen at this <a href=\"https://www.facebook.com/notes/facebook-engineering/xhp-a-new-way-to-write-php/294003943919\">XHP</a>.</p>\n",
            "content_text": "Anthony Ferrara taking on the painful process of automatically determining the correct context for escaping data in templates:\n\nImagine being able to put a variable in a JavaScript string in your template, and have the engine transparently encode it correctly for you. Awesome, right?\n\nFrom Tries and Lexers.\nThe best attempt I&#8217;ve seen at this XHP.",
            "date_published": "2015-09-18T08:30:14-06:00",
            "date_modified": "2015-09-18T08:30:14-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "anthony-ferrara",
                "xhp",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=11794",
            "url": "https://blog.josephscott.org/2015/04/21/beware-of-crypto-combinations/",
            "title": "Beware of Crypto Combinations",
            "content_html": "<p><a href=\"http://en.wikipedia.org/wiki/Bcrypt\">Bcrypt</a> has in interesting limitation, it only uses the first 72 bytes to generate a hash.  Anthony Ferrara covers why you may want to live with that limitation: <a href=\"http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html\">Security Issue: Combining Bcrypt With Other Hash Functions</a>.</p>\n<p>The specific example he covers is pre-hashing with the raw output of <a href=\"http://php.net/manual/en/function.hash-hmac.php\">hash_hmac()</a>, which can contain null bytes:</p>\n<blockquote><p>\nthis means that the output can contain null bytes. In fact, it means that on average 1 out of every 256 passwords (or 0.39%) will have a leading null byte. So we only need to try approximately 177 passwords to get a 50% chance of finding a hash with a leading null byte. And we only need to try approximately 177 users to get a 50% chance of finding a user with a leading null byte. So trying 31329 permutations of users and passwords gives us a 25% chance of finding one that will work.</p>\n<p>&#8230;</p>\n<p>This is <strong>bad</strong>. This is <strong>really bad</strong>.\n</p></blockquote>\n<p>Oh the null byte, you have been the source of many unexpected results.</p>\n<p>If you don&#8217;t use the raw output of <code>hash_hmac()</code> then you won&#8217;t get null bytes and you&#8217;ll be fine.  By default raw output is set to false.</p>\n<blockquote><p>\nYou are 100% safe if you do one of the following:</p>\n<ol>\n<li>Use straight bcrypt (don&#8217;t pre-hash)</li>\n<li>Use hex output from the pre-hash</li>\n<li>Base64 encode the raw output of a pre-hash</li>\n</ol>\n<p>If you are using raw output, encode it first, and you&#8217;re safe.\n</p></blockquote>\n<p>There are so many ways to mess up cryptography.  <a href=\"https://josephscott.org/archives/2015/04/which-kneecap/\">This is not the kneecap you want to get shot in</a>.  Nearly every situation should stick with existing, widely used and tested, crypto options.</p>\n",
            "content_text": "Bcrypt has in interesting limitation, it only uses the first 72 bytes to generate a hash.  Anthony Ferrara covers why you may want to live with that limitation: Security Issue: Combining Bcrypt With Other Hash Functions.\nThe specific example he covers is pre-hashing with the raw output of hash_hmac(), which can contain null bytes:\n\nthis means that the output can contain null bytes. In fact, it means that on average 1 out of every 256 passwords (or 0.39%) will have a leading null byte. So we only need to try approximately 177 passwords to get a 50% chance of finding a hash with a leading null byte. And we only need to try approximately 177 users to get a 50% chance of finding a user with a leading null byte. So trying 31329 permutations of users and passwords gives us a 25% chance of finding one that will work.\n&#8230;\nThis is bad. This is really bad.\n\nOh the null byte, you have been the source of many unexpected results.\nIf you don&#8217;t use the raw output of hash_hmac() then you won&#8217;t get null bytes and you&#8217;ll be fine.  By default raw output is set to false.\n\nYou are 100% safe if you do one of the following:\n\nUse straight bcrypt (don&#8217;t pre-hash)\nUse hex output from the pre-hash\nBase64 encode the raw output of a pre-hash\n\nIf you are using raw output, encode it first, and you&#8217;re safe.\n\nThere are so many ways to mess up cryptography.  This is not the kneecap you want to get shot in.  Nearly every situation should stick with existing, widely used and tested, crypto options.",
            "date_published": "2015-04-21T14:50:24-06:00",
            "date_modified": "2015-04-21T14:50:24-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "anthony-ferrara",
                "bcrypt",
                "PHP",
                "Posts"
            ]
        },
        {
            "id": "https://josephscott.org/?p=8368",
            "url": "https://blog.josephscott.org/2013/06/26/forward-compatibility-another-reason-for-named-parameters-in-php/",
            "title": "Forward Compatibility, Another Reason for Named Parameters in PHP",
            "content_html": "<p>While Anthony Ferrara&#8217;s <a href=\"http://blog.ircmaxell.com/2013/06/backwards-compatibility-is-for-suckers.html\">Backwards Compatibility Is For Suckers</a> starts off as mostly flame bait, he does bring up one important issue: forward compatibility.</p>\n<p>The PHP example he cites is the new <a href=\"http://us3.php.net/password_hash\">password_hash</a> function.  It looks like this:</p>\n<pre><code>password_hash( $password, $algo, array $options = array() );</code></pre>\n<p>Currently <code>$options</code> supports two values: <code>salt</code> and <code>cost</code>.  The forward compatibility part is that new values can be added to <code>$options</code> without having to change the function signature.</p>\n<p>This is the best you can do with PHP right now, which is a bummer.  The (much) better solution would be to have named parameter support.  Use Python as the reference for this.  No more hiding parameters in an opaque options array, instead expose all of them in the function signature.</p>\n<p>Until PHP has proper named parameter support we&#8217;ll have to continue the awkward use of arrays to hide current and future optional parameters.</p>\n",
            "content_text": "While Anthony Ferrara&#8217;s Backwards Compatibility Is For Suckers starts off as mostly flame bait, he does bring up one important issue: forward compatibility.\nThe PHP example he cites is the new password_hash function.  It looks like this:\npassword_hash( $password, $algo, array $options = array() );\nCurrently $options supports two values: salt and cost.  The forward compatibility part is that new values can be added to $options without having to change the function signature.\nThis is the best you can do with PHP right now, which is a bummer.  The (much) better solution would be to have named parameter support.  Use Python as the reference for this.  No more hiding parameters in an opaque options array, instead expose all of them in the function signature.\nUntil PHP has proper named parameter support we&#8217;ll have to continue the awkward use of arrays to hide current and future optional parameters.",
            "date_published": "2013-06-26T04:14:32-06:00",
            "date_modified": "2013-06-26T04:14:32-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "anthony-ferrara",
                "forward-compatibility",
                "PHP",
                "Posts"
            ]
        }
    ]
}