{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/principle-of-least-surprise/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/principle-of-least-surprise/",
    "feed_url": "https://blog.josephscott.org/tag/principle-of-least-surprise/feed/json/",
    "language": "en-US",
    "title": "principle-of-least-surprise &#8211; Joseph Scott",
    "items": [
        {
            "id": "https://blog.josephscott.org/?p=17074",
            "url": "https://blog.josephscott.org/2018/10/30/principle-of-least-surprise-tofixed-in-javascript/",
            "title": "Principle Of Least Surprise: toFixed() in JavaScript",
            "content_html": "<p>The &#8220;Principle Of Least Surprise&#8221; ( sometimes referred to as &#8220;Principle Of Least Astonishment&#8221; ) as described by M. F. Cowlishaw in the paper &#8220;<a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/mike-cowlishaw/rexx.pdf\">The design of the REXX language</a>&#8221; in 1984:</p>\n<blockquote><p>It is difficult to define exactly how to meet user expectations, but it helps to ask the question: Could there be a high astonishment factor associated with the new feature? If a feature is accidentally misapplied by the user and causes what appears to him to be an unpredictable result, that feature has a high astonishment factor and is therefore undesirable. If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature.</p></blockquote>\n<p>While being a bit on the squishy side, this still a very useful principle.</p>\n<p>I recently ran into a violation of this principle while using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\">Number.prototype.toFixed()</a> in JavaScript.</p>\n<p>The code was capturing a time value using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance/now\">performance.now()</a>. Since it was already counting in milliseconds, and I was exposing the result as JSON, I didn&#8217;t really need 15 decimal places. No problem, I&#8217;ll use <code>toFixed()</code> to reduce it to 3 decimal places. Here is a simplified version of the code and the result:</p>\n<pre class=\"line-numbers\"><code class=\"language-javascript\">var now = performance.now().toFixed( 3 );\r\nvar share = JSON.stringify( { now: now } );\r\n\r\n\r\n// share is now {\"now\": \"8.618\"}\r\n</code></pre>\n<p>That is the point where I realized something wasn&#8217;t right.  When calling <code>performance.now()</code> you get back a <code>double</code> ( <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp\">DOMHighResTimeStamp type</a> ).  Why then was it coming out as a string in the JSON?</p>\n<p>It turns out that <code>toFixed()</code> &#8220;formats a number using fixed-point notation&#8221; by returning a string.  The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\">MDN docs</a> do indicate that the return value is a string, but I contend that this is completely unexpected.  In order to keep the value as a <code>double</code>, you need to wrap the whole thing in <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat\">parseFloat()</a>:</p>\n<pre class=\"line-numbers\"><code class=\"language-javascript\">var now = parseFloat( performance.now().toFixed( 3 ) );\r\nvar share = JSON.stringify( { now: now } );\r\n\r\n\r\n// share is now {\"now\": 8.618}\r\n</code></pre>\n<p>It would be clearer, and less work ( <code>parseFloat()</code> can be a hit in performance ), if <code>toFixed()</code> preserved the variable type and returned a double.</p>\n",
            "content_text": "The &#8220;Principle Of Least Surprise&#8221; ( sometimes referred to as &#8220;Principle Of Least Astonishment&#8221; ) as described by M. F. Cowlishaw in the paper &#8220;The design of the REXX language&#8221; in 1984:\nIt is difficult to define exactly how to meet user expectations, but it helps to ask the question: Could there be a high astonishment factor associated with the new feature? If a feature is accidentally misapplied by the user and causes what appears to him to be an unpredictable result, that feature has a high astonishment factor and is therefore undesirable. If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature.\nWhile being a bit on the squishy side, this still a very useful principle.\nI recently ran into a violation of this principle while using Number.prototype.toFixed() in JavaScript.\nThe code was capturing a time value using performance.now(). Since it was already counting in milliseconds, and I was exposing the result as JSON, I didn&#8217;t really need 15 decimal places. No problem, I&#8217;ll use toFixed() to reduce it to 3 decimal places. Here is a simplified version of the code and the result:\nvar now = performance.now().toFixed( 3 );\r\nvar share = JSON.stringify( { now: now } );\r\n\r\n\r\n// share is now {\"now\": \"8.618\"}\r\n\nThat is the point where I realized something wasn&#8217;t right.  When calling performance.now() you get back a double ( DOMHighResTimeStamp type ).  Why then was it coming out as a string in the JSON?\nIt turns out that toFixed() &#8220;formats a number using fixed-point notation&#8221; by returning a string.  The MDN docs do indicate that the return value is a string, but I contend that this is completely unexpected.  In order to keep the value as a double, you need to wrap the whole thing in parseFloat():\nvar now = parseFloat( performance.now().toFixed( 3 ) );\r\nvar share = JSON.stringify( { now: now } );\r\n\r\n\r\n// share is now {\"now\": 8.618}\r\n\nIt would be clearer, and less work ( parseFloat() can be a hit in performance ), if toFixed() preserved the variable type and returned a double.",
            "date_published": "2018-10-30T12:31:45-06:00",
            "date_modified": "2018-10-30T12:31:45-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "javascript",
                "principle-of-least-surprise"
            ]
        }
    ]
}