{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/coding-horror/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/coding-horror/",
    "feed_url": "https://blog.josephscott.org/tag/coding-horror/feed/json/",
    "language": "en-US",
    "title": "coding-horror &#8211; Joseph Scott",
    "items": [
        {
            "id": "http://josephscott.org/?p=5676",
            "url": "https://blog.josephscott.org/2012/04/09/slow-hashing/",
            "title": "Slow Hashing",
            "content_html": "<p>The majority of the <a href='http://www.codinghorror.com/blog/2012/04/speed-hashing.html'>Coding Horror: Speed Hashing</a> post talks about speed based on MD5.  It isn&#8217;t until the very bottom that you see this:</p>\n<blockquote><p>\nIf you are a developer:</p>\n<p>Use bcrypt or PBKDF2 exclusively to hash anything you need to be secure. These new hashes were specifically designed to be difficult to implement on GPUs. Do not use any other form of hash. Almost every other popular hashing scheme is vulnerable to brute forcing by arrays of commodity GPUs, which only get faster and more parallel and easier to program for every year.\n</p></blockquote>\n<p>I&#8217;m not sure why that wasn&#8217;t at the very top.</p>\n<p>If you are still using MD5 to hash passwords (or worse, aren&#8217;t hashing passwords at all) then please stop and go use <a href=\"http://bcrypt.sourceforge.net/\">bcrypt</a>.  For those using PHP <a href=\"http://www.openwall.com/phpass/\">phpass</a> is a great option.</p>\n<p>For password hashes you want the process to be slow.  There is of course a trade off.  Here is a PHP example:</p>\n<p>[sourcecode lang=&#8221;php&#8221;]<br />\ncrypt( &#8216;password&#8217;, &#8216;$2a$12$usesomesillystringforsalt$&#8217; );<br />\n[/sourcecode]</p>\n<p>The <code>$2a</code> tells <a href=\"http://us.php.net/crypt\">crypt</a> to use <code>CRYPT_BLOWFISH</code>.  The <code>$15$</code> is the cost parameter, ranging from 04 to 31.  Running this on my Core 2 Duo laptop takes 0.4 seconds.  Increasing the cost parameter increases the amount of time it takes to compute the hash.  For my Core 2 Duo it looks like:</p>\n<p><strong>Cost 12:</strong> 00.4 seconds<br />\n<strong>Cost 13:</strong> 00.7 seconds<br />\n<strong>Cost 14:</strong> 01.4 seconds<br />\n<strong>Cost 15:</strong> 02.8 seconds<br />\n<strong>Cost 16:</strong> 05.5 seconds<br />\n<strong>Cost 17:</strong> 11.1 seconds<br />\n<strong>Cost 18:</strong> 22.1 seconds</p>\n<p>While having a cost of 18 might sound exciting from the point of view of making brute force attacks more difficult it would make for a horrible user experience.  Remember that each time a use fills out the log in form on your site you have to hash the password they entered to see if the matches the one your in your database.  Waiting 22 seconds per log in attempt would drive your users nuts.</p>\n<p>So how high should the cost be to make brute force attacks impractical, but low enough to still provide a good user experience?  Some of that is going to depend on the power of your servers, but for now lets stick with my Core 2 Duo example.  If your possible password combinations were lower case letters, upper case letters, and numbers for a 7 character string then you&#8217;d be looking at 62 ^ 7, or 3,521,614,606,208 combinations.</p>\n<p>The speed hashing post indicated that for MD5 all 7 character passwords of that type could be calculated in 4 minutes.  If we choose a cost of 13 (meaning 0.7 seconds per password) and I&#8217;ve done my math correctly, it would take 159,528 years to do the same thing on my Core 2 Duo.</p>\n<p>If your server is 10 times faster than my Core 2 Duo then a cost of 13 may still be fairly reasonable.  A single hash would take 0.07 seconds and computing hashes for all 7 character passwords would take 15,952 years.  Even another 100x increase in speed would still mean 159 years.</p>\n<p>None of this takes into consideration the possibility of spreading the brute force attack across multiple servers of course.  But the concept is still the same.  Slower hash techniques mean you&#8217;ll need a larger number of servers to compute all of the possible combinations in a reasonable amount of time compared to a very fast hash, like MD5.</p>\n",
            "content_text": "The majority of the Coding Horror: Speed Hashing post talks about speed based on MD5.  It isn&#8217;t until the very bottom that you see this:\n\nIf you are a developer:\nUse bcrypt or PBKDF2 exclusively to hash anything you need to be secure. These new hashes were specifically designed to be difficult to implement on GPUs. Do not use any other form of hash. Almost every other popular hashing scheme is vulnerable to brute forcing by arrays of commodity GPUs, which only get faster and more parallel and easier to program for every year.\n\nI&#8217;m not sure why that wasn&#8217;t at the very top.\nIf you are still using MD5 to hash passwords (or worse, aren&#8217;t hashing passwords at all) then please stop and go use bcrypt.  For those using PHP phpass is a great option.\nFor password hashes you want the process to be slow.  There is of course a trade off.  Here is a PHP example:\n[sourcecode lang=&#8221;php&#8221;]\ncrypt( &#8216;password&#8217;, &#8216;$2a$12$usesomesillystringforsalt$&#8217; );\n[/sourcecode]\nThe $2a tells crypt to use CRYPT_BLOWFISH.  The $15$ is the cost parameter, ranging from 04 to 31.  Running this on my Core 2 Duo laptop takes 0.4 seconds.  Increasing the cost parameter increases the amount of time it takes to compute the hash.  For my Core 2 Duo it looks like:\nCost 12: 00.4 seconds\nCost 13: 00.7 seconds\nCost 14: 01.4 seconds\nCost 15: 02.8 seconds\nCost 16: 05.5 seconds\nCost 17: 11.1 seconds\nCost 18: 22.1 seconds\nWhile having a cost of 18 might sound exciting from the point of view of making brute force attacks more difficult it would make for a horrible user experience.  Remember that each time a use fills out the log in form on your site you have to hash the password they entered to see if the matches the one your in your database.  Waiting 22 seconds per log in attempt would drive your users nuts.\nSo how high should the cost be to make brute force attacks impractical, but low enough to still provide a good user experience?  Some of that is going to depend on the power of your servers, but for now lets stick with my Core 2 Duo example.  If your possible password combinations were lower case letters, upper case letters, and numbers for a 7 character string then you&#8217;d be looking at 62 ^ 7, or 3,521,614,606,208 combinations.\nThe speed hashing post indicated that for MD5 all 7 character passwords of that type could be calculated in 4 minutes.  If we choose a cost of 13 (meaning 0.7 seconds per password) and I&#8217;ve done my math correctly, it would take 159,528 years to do the same thing on my Core 2 Duo.\nIf your server is 10 times faster than my Core 2 Duo then a cost of 13 may still be fairly reasonable.  A single hash would take 0.07 seconds and computing hashes for all 7 character passwords would take 15,952 years.  Even another 100x increase in speed would still mean 159 years.\nNone of this takes into consideration the possibility of spreading the brute force attack across multiple servers of course.  But the concept is still the same.  Slower hash techniques mean you&#8217;ll need a larger number of servers to compute all of the possible combinations in a reasonable amount of time compared to a very fast hash, like MD5.",
            "date_published": "2012-04-09T10:25:05-06:00",
            "date_modified": "2012-04-09T10:25:05-06:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "bcrypt",
                "coding-horror",
                "crypt",
                "hash",
                "md5",
                "PHP",
                "Posts"
            ]
        }
    ]
}