{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/guid/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/guid/",
    "feed_url": "https://blog.josephscott.org/tag/guid/feed/json/",
    "language": "en-US",
    "title": "guid &#8211; Joseph Scott",
    "items": [
        {
            "id": "http://joseph.randomnetworks.com/?p=532",
            "url": "https://blog.josephscott.org/2005/12/31/rhyll-uuid-generator/",
            "title": "Rhyll \u2013 UUID Generator",
            "content_html": "<p>Just quick note to that I&#8217;ve added a simple <a href=\"http://rhyll.com/uuidgenerator/\">UUID generator</a> to <a href=\"http://rhyll.com/\">Rhyll</a>.</p>\n",
            "content_text": "Just quick note to that I&#8217;ve added a simple UUID generator to Rhyll.",
            "date_published": "2005-12-31T19:18:56-07:00",
            "date_modified": "2005-12-31T19:18:56-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "guid",
                "rhyll",
                "uuid",
                "josephscott"
            ]
        },
        {
            "id": "http://joseph.randomnetworks.com/?p=528",
            "url": "https://blog.josephscott.org/2005/12/08/mysql-to-postgresql-and-uuidguids/",
            "title": "MySQL to PostgreSQL and UUID/GUIDs",
            "content_html": "<p>(Warning, I tend to use UUID instead of GUID.  For purposes of this post consider them interchangeable.)</p>\n<p>I&#8217;ve already <a href=\"http://joseph.randomnetworks.com/archives/2005/11/21/feedlounge-switches-to-postgresql/\">mentioned</a> the announcement of <a href=\"http://www.feedlounge.com/\">FeedLounge</a> making the <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/\">move from MySQL to PostgreSQL</a> last month, but the discussion is still on going.  If you haven&#8217;t yet, go read all of the comments on the announcement.  This has to be some of the most productive and level headed (no flames yet) set of blog comments I&#8217;ve seen in a long time.  For those of you who are coming late to this story let me bring you up to speed:</p>\n<p>FeedLounge started with MySQL as their database, with the MyISAM table types.  They ran into problems and so moved to the <a href=\"http://www.innodb.com/index.php\">InnoDB</a> table type in MySQL.  Still not completely happy they did more research and decided to try out <a href=\"http://www.postgresql.com/\">PostgreSQL</a> for their database needs.  Their tests showed that MySQL InnoDB database was 34GB, in PostgreSQL it was 9.6GB.  Restores in MySQL took more than 24 hours, in PostgreSQL it was less than 5 hours.  These numbers resulted in better performance and reduced time.</p>\n<p>It has been more than two weeks since the initial announcement and there are still new comments being added.  As of this morning there are <strike>34</strike> 35 comments.  Some of the comments have come from people who are very knowledgable about MySQL and the size of InnoDB indexes <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-406\">became the focus</a> for why InnoDB was so much bigger than PostgreSQL.  Using InnoDB with UUIDs as the primary key was <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-409\">identified as a problem</a>, especially in the area of performance.</p>\n<p>Things continued to get more interesting when Heikki Tuuri (the creator of InnoDB) left a comment <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-451\">confirming the size problems in InnoDB</a> when using a UUID as a primary key.  It seems that using a UUID in this way causes a couple of problems, the first being that InnoDB wants to keep things in index order, which is great for indexes on sequential numbers but bad for seemingly random data (PostgreSQL can do the same thing with <a href=\"http://www.postgresql.org/docs/8.1/interactive/sql-cluster.html\">cluster</a>).  The next problem is that secondary indexes in the same table get copies of the primary key index to making finding things faster.  This, at least in part, was what caused the size difference.</p>\n<p><a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-455\">Heikki&#8217;s solution</a> (and others have mentioned this) is to use an auto_increment field as the primary key and create a unique secondary index on the UUID field.  This would make the primary key index size much smaller and still allow InnoDB to do index lookups on the UUID field.  That would seem to solve the problem, but there hasn&#8217;t been any feedback yet to confirm if it fixed all of the differences between InnoDB and PostgreSQL.</p>\n<p>There is something about having to add an extra field to my table to make the database perform better that doesn&#8217;t seem quite right though.  I don&#8217;t have anything concrete that I can point to showing that this isn&#8217;t a good idea, but it doesn&#8217;t feel right.  For those who are running into these same types of problems though, it might be something to try, at least until you get a chance to try out PostgreSQL.</p>\n",
            "content_text": "(Warning, I tend to use UUID instead of GUID.  For purposes of this post consider them interchangeable.)\nI&#8217;ve already mentioned the announcement of FeedLounge making the move from MySQL to PostgreSQL last month, but the discussion is still on going.  If you haven&#8217;t yet, go read all of the comments on the announcement.  This has to be some of the most productive and level headed (no flames yet) set of blog comments I&#8217;ve seen in a long time.  For those of you who are coming late to this story let me bring you up to speed:\nFeedLounge started with MySQL as their database, with the MyISAM table types.  They ran into problems and so moved to the InnoDB table type in MySQL.  Still not completely happy they did more research and decided to try out PostgreSQL for their database needs.  Their tests showed that MySQL InnoDB database was 34GB, in PostgreSQL it was 9.6GB.  Restores in MySQL took more than 24 hours, in PostgreSQL it was less than 5 hours.  These numbers resulted in better performance and reduced time.\nIt has been more than two weeks since the initial announcement and there are still new comments being added.  As of this morning there are 34 35 comments.  Some of the comments have come from people who are very knowledgable about MySQL and the size of InnoDB indexes became the focus for why InnoDB was so much bigger than PostgreSQL.  Using InnoDB with UUIDs as the primary key was identified as a problem, especially in the area of performance.\nThings continued to get more interesting when Heikki Tuuri (the creator of InnoDB) left a comment confirming the size problems in InnoDB when using a UUID as a primary key.  It seems that using a UUID in this way causes a couple of problems, the first being that InnoDB wants to keep things in index order, which is great for indexes on sequential numbers but bad for seemingly random data (PostgreSQL can do the same thing with cluster).  The next problem is that secondary indexes in the same table get copies of the primary key index to making finding things faster.  This, at least in part, was what caused the size difference.\nHeikki&#8217;s solution (and others have mentioned this) is to use an auto_increment field as the primary key and create a unique secondary index on the UUID field.  This would make the primary key index size much smaller and still allow InnoDB to do index lookups on the UUID field.  That would seem to solve the problem, but there hasn&#8217;t been any feedback yet to confirm if it fixed all of the differences between InnoDB and PostgreSQL.\nThere is something about having to add an extra field to my table to make the database perform better that doesn&#8217;t seem quite right though.  I don&#8217;t have anything concrete that I can point to showing that this isn&#8217;t a good idea, but it doesn&#8217;t feel right.  For those who are running into these same types of problems though, it might be something to try, at least until you get a chance to try out PostgreSQL.",
            "date_published": "2005-12-08T11:40:07-07:00",
            "date_modified": "2005-12-08T11:40:07-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "Database",
                "feedlounge",
                "guid",
                "MySQL",
                "PostgreSQL",
                "uuid",
                "josephscott"
            ]
        }
    ]
}