{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://blog.josephscott.org/tag/feedlounge/feed/json/ -- and add it your reader.",
    "home_page_url": "https://blog.josephscott.org/tag/feedlounge/",
    "feed_url": "https://blog.josephscott.org/tag/feedlounge/feed/json/",
    "language": "en-US",
    "title": "feedlounge &#8211; Joseph Scott",
    "items": [
        {
            "id": "http://joseph.randomnetworks.com/?p=528",
            "url": "https://blog.josephscott.org/2005/12/08/mysql-to-postgresql-and-uuidguids/",
            "title": "MySQL to PostgreSQL and UUID/GUIDs",
            "content_html": "<p>(Warning, I tend to use UUID instead of GUID.  For purposes of this post consider them interchangeable.)</p>\n<p>I&#8217;ve already <a href=\"http://joseph.randomnetworks.com/archives/2005/11/21/feedlounge-switches-to-postgresql/\">mentioned</a> the announcement of <a href=\"http://www.feedlounge.com/\">FeedLounge</a> making the <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/\">move from MySQL to PostgreSQL</a> last month, but the discussion is still on going.  If you haven&#8217;t yet, go read all of the comments on the announcement.  This has to be some of the most productive and level headed (no flames yet) set of blog comments I&#8217;ve seen in a long time.  For those of you who are coming late to this story let me bring you up to speed:</p>\n<p>FeedLounge started with MySQL as their database, with the MyISAM table types.  They ran into problems and so moved to the <a href=\"http://www.innodb.com/index.php\">InnoDB</a> table type in MySQL.  Still not completely happy they did more research and decided to try out <a href=\"http://www.postgresql.com/\">PostgreSQL</a> for their database needs.  Their tests showed that MySQL InnoDB database was 34GB, in PostgreSQL it was 9.6GB.  Restores in MySQL took more than 24 hours, in PostgreSQL it was less than 5 hours.  These numbers resulted in better performance and reduced time.</p>\n<p>It has been more than two weeks since the initial announcement and there are still new comments being added.  As of this morning there are <strike>34</strike> 35 comments.  Some of the comments have come from people who are very knowledgable about MySQL and the size of InnoDB indexes <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-406\">became the focus</a> for why InnoDB was so much bigger than PostgreSQL.  Using InnoDB with UUIDs as the primary key was <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-409\">identified as a problem</a>, especially in the area of performance.</p>\n<p>Things continued to get more interesting when Heikki Tuuri (the creator of InnoDB) left a comment <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-451\">confirming the size problems in InnoDB</a> when using a UUID as a primary key.  It seems that using a UUID in this way causes a couple of problems, the first being that InnoDB wants to keep things in index order, which is great for indexes on sequential numbers but bad for seemingly random data (PostgreSQL can do the same thing with <a href=\"http://www.postgresql.org/docs/8.1/interactive/sql-cluster.html\">cluster</a>).  The next problem is that secondary indexes in the same table get copies of the primary key index to making finding things faster.  This, at least in part, was what caused the size difference.</p>\n<p><a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/#comment-455\">Heikki&#8217;s solution</a> (and others have mentioned this) is to use an auto_increment field as the primary key and create a unique secondary index on the UUID field.  This would make the primary key index size much smaller and still allow InnoDB to do index lookups on the UUID field.  That would seem to solve the problem, but there hasn&#8217;t been any feedback yet to confirm if it fixed all of the differences between InnoDB and PostgreSQL.</p>\n<p>There is something about having to add an extra field to my table to make the database perform better that doesn&#8217;t seem quite right though.  I don&#8217;t have anything concrete that I can point to showing that this isn&#8217;t a good idea, but it doesn&#8217;t feel right.  For those who are running into these same types of problems though, it might be something to try, at least until you get a chance to try out PostgreSQL.</p>\n",
            "content_text": "(Warning, I tend to use UUID instead of GUID.  For purposes of this post consider them interchangeable.)\nI&#8217;ve already mentioned the announcement of FeedLounge making the move from MySQL to PostgreSQL last month, but the discussion is still on going.  If you haven&#8217;t yet, go read all of the comments on the announcement.  This has to be some of the most productive and level headed (no flames yet) set of blog comments I&#8217;ve seen in a long time.  For those of you who are coming late to this story let me bring you up to speed:\nFeedLounge started with MySQL as their database, with the MyISAM table types.  They ran into problems and so moved to the InnoDB table type in MySQL.  Still not completely happy they did more research and decided to try out PostgreSQL for their database needs.  Their tests showed that MySQL InnoDB database was 34GB, in PostgreSQL it was 9.6GB.  Restores in MySQL took more than 24 hours, in PostgreSQL it was less than 5 hours.  These numbers resulted in better performance and reduced time.\nIt has been more than two weeks since the initial announcement and there are still new comments being added.  As of this morning there are 34 35 comments.  Some of the comments have come from people who are very knowledgable about MySQL and the size of InnoDB indexes became the focus for why InnoDB was so much bigger than PostgreSQL.  Using InnoDB with UUIDs as the primary key was identified as a problem, especially in the area of performance.\nThings continued to get more interesting when Heikki Tuuri (the creator of InnoDB) left a comment confirming the size problems in InnoDB when using a UUID as a primary key.  It seems that using a UUID in this way causes a couple of problems, the first being that InnoDB wants to keep things in index order, which is great for indexes on sequential numbers but bad for seemingly random data (PostgreSQL can do the same thing with cluster).  The next problem is that secondary indexes in the same table get copies of the primary key index to making finding things faster.  This, at least in part, was what caused the size difference.\nHeikki&#8217;s solution (and others have mentioned this) is to use an auto_increment field as the primary key and create a unique secondary index on the UUID field.  This would make the primary key index size much smaller and still allow InnoDB to do index lookups on the UUID field.  That would seem to solve the problem, but there hasn&#8217;t been any feedback yet to confirm if it fixed all of the differences between InnoDB and PostgreSQL.\nThere is something about having to add an extra field to my table to make the database perform better that doesn&#8217;t seem quite right though.  I don&#8217;t have anything concrete that I can point to showing that this isn&#8217;t a good idea, but it doesn&#8217;t feel right.  For those who are running into these same types of problems though, it might be something to try, at least until you get a chance to try out PostgreSQL.",
            "date_published": "2005-12-08T11:40:07-07:00",
            "date_modified": "2005-12-08T11:40:07-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "Database",
                "feedlounge",
                "guid",
                "MySQL",
                "PostgreSQL",
                "uuid",
                "josephscott"
            ]
        },
        {
            "id": "http://joseph.randomnetworks.com/?p=521",
            "url": "https://blog.josephscott.org/2005/11/21/feedlounge-switches-to-postgresql/",
            "title": "FeedLounge Switches To PostgreSQL",
            "content_html": "<p>This could turn into an interesting case study, <a href=\"http://www.feedlounge.com/\">FeedLounge</a> has <a href=\"http://feedlounge.com/blog/2005/11/20/switched-to-postgresql/\">switched databases</a>, from <a href=\"http://www.mysql.com/\">MySQL</a> to <a href=\"http://www.postgresql.org/\">PostgreSQL</a>.  The two main factors they listed were database size (34Gig for MySQL/InnoDB vs. 9.6Gig for PostgreSQL) and restoration time (24+ hours to restore database in MySQL vs. less than 5 hours for PostgreSQL).</p>\n<p>I&#8217;m surprised to here about the huge difference in database size between MySQL (w/InnoDB) and PostgreSQL.  Perhaps the different indexing techniques are responsible for this, I&#8217;m not sure.  For large databases the ability to cut your storage requirements by more than 1/3 is huge.  My gut feeling though is that this would not be the norm though.  More testing is definitely in order to make this comparison more meaningful.</p>\n<p>The huge difference in database restoration time also strikes me as a bit high.  Certainly another area where further tests would be interesting to see if this pattern holds true in general.  Obviously being able to restore your database in less than 1/3 the time is a good thing.</p>\n<p>The real kicker in all this though is the chance to make use of the additional features found in PostgreSQL (they point this out in their write up).  I hope that <a href=\"http://www.alexking.org/\">Alex</a> continues to write about how this transition progresses.</p>\n",
            "content_text": "This could turn into an interesting case study, FeedLounge has switched databases, from MySQL to PostgreSQL.  The two main factors they listed were database size (34Gig for MySQL/InnoDB vs. 9.6Gig for PostgreSQL) and restoration time (24+ hours to restore database in MySQL vs. less than 5 hours for PostgreSQL).\nI&#8217;m surprised to here about the huge difference in database size between MySQL (w/InnoDB) and PostgreSQL.  Perhaps the different indexing techniques are responsible for this, I&#8217;m not sure.  For large databases the ability to cut your storage requirements by more than 1/3 is huge.  My gut feeling though is that this would not be the norm though.  More testing is definitely in order to make this comparison more meaningful.\nThe huge difference in database restoration time also strikes me as a bit high.  Certainly another area where further tests would be interesting to see if this pattern holds true in general.  Obviously being able to restore your database in less than 1/3 the time is a good thing.\nThe real kicker in all this though is the chance to make use of the additional features found in PostgreSQL (they point this out in their write up).  I hope that Alex continues to write about how this transition progresses.",
            "date_published": "2005-11-21T10:01:11-07:00",
            "date_modified": "2005-11-21T10:01:11-07:00",
            "authors": [
                {
                    "name": "josephscott",
                    "url": "https://blog.josephscott.org/author/josephscott/",
                    "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "josephscott",
                "url": "https://blog.josephscott.org/author/josephscott/",
                "avatar": "https://secure.gravatar.com/avatar/582b66ad5ae1b69c7601a990cb9a661a?s=512&d=mm&r=g"
            },
            "tags": [
                "Database",
                "feedlounge",
                "MySQL",
                "PostgreSQL",
                "josephscott"
            ]
        }
    ]
}